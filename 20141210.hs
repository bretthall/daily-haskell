{--

Solution to @1HaskellADay http://lpaste.net/116147

"Hello, Strand, you're looking lovely in that dress!"

No, wait.

That's 'complimenting' a Strand, not 'complementing' a strand.

Anyway.

http://rosalind.info/problems/revc/

Complementing a Strand of DNA

The Secondary and Tertiary Structures of DNA

Problem

In DNA strings, symbols 'A' and 'T' are complements of each other, as are 'C'
and 'G'.

The reverse complement of a DNA string s is the string sc formed by reversing
the symbols of s, then taking the complement of each symbol (e.g., the reverse
complement of "GTCA" is "TGAC").

Given: A DNA string s of length at most 1000 bp.

Return: The reverse complement s(c) of s.

Sample Dataset
AAAACCCGGT

Sample Output
ACCGGGTTTT

--}

import Data.Vector.Unboxed as V
import Data.Word
import Data.ByteString as B
import Data.ByteString.Lazy as BL
import Data.Char
import Data.Maybe
import System.Environment
import Control.Parallel.Strategies
import Control.DeepSeq as DS

revc :: String -> String
revc = Prelude.map swapChar . Prelude.reverse

swapChar :: Char -> Char
swapChar c | c == 'A' = 'T'
           | c == 'T' = 'A'
           | c == 'C' = 'G'
           | c == 'G' = 'C'

-- *Main Data.List> revc "AAAACCCGGT"
-- "ACCGGGTTTT"
-- That works, but on big files it will be slow and use A LOT of memory (see notes below)

-- Try byte strings with a look-up table to speed up the character swapping (and try to parallelize as well)

revcBS :: B.ByteString -> B.ByteString
revcBS = B.map swapCharBS . B.reverse

swapCharBS :: Word8 -> Word8
swapCharBS = (swapTable !).fromIntegral

swapTable :: V.Vector Word8
swapTable = V.replicate 128 x8 V.// Prelude.map fi [(a8, t8), (t8, a8), (c8, g8), (g8, c8)]
    where 
      fi (a, b) = (fromIntegral a, b)

to8 :: Char -> Word8
to8 = fromIntegral.ord

x8 = to8 'X'
a8 = to8 'A'
c8 = to8 'C'
g8 = to8 'G'
t8 = to8 'T'

{-- 
Okay, you've got the reversed, complemented strand from the sample snippet
above, now how about something ... meatier: rosalind_revc.txt which is found at
http://lpaste.net/116148
--}

type Method = FilePath -> FilePath -> IO ()

revcString :: Method
revcString inFile outFile = Prelude.readFile inFile >>= Prelude.writeFile outFile . revc

revcByteString :: Method
revcByteString inFile outFile = B.readFile inFile >>= B.writeFile outFile . revcBS

revcByteStringChunked :: Method
revcByteStringChunked inFile outFile = do
  dna <- BL.readFile inFile
  let dnaChunks = Prelude.reverse $ BL.toChunks dna
  let revcChunks = Prelude.map revcBS dnaChunks
  BL.writeFile outFile $ BL.fromChunks revcChunks

revcByteStringParallel :: Method
revcByteStringParallel inFile outFile = do
  dna <- BL.readFile inFile
  let dnaChunks = Prelude.reverse $ BL.toChunks dna
  let revcChunks = Prelude.map revcBS dnaChunks `using` parList rdeepseq
  BL.writeFile outFile $ BL.fromChunks revcChunks

revcByteStringParallelForceRead :: Method
revcByteStringParallelForceRead inFile outFile = do
  dna <- BL.readFile inFile
  let dnaChunks = Prelude.reverse $ BL.toChunks $ DS.force dna
  let revcChunks = Prelude.map revcBS dnaChunks `using` parList rdeepseq
  BL.writeFile outFile $ BL.fromChunks revcChunks

method :: String -> Method
method name = fromJust $ Prelude.lookup name methods
    where
      methods = [("string", revcString), 
                 ("bs", revcByteString),
                 ("bsc", revcByteStringChunked),
                 ("bsp", revcByteStringParallel),
                 ("bspf", revcByteStringParallelForceRead)]

main = do
  [name, inFile, outFile] <- getArgs
  method name inFile outFile

-- All testing carried out on a 100MB file generated by http://lpaste.net/116095

-- The "string" method works but to get it to work on a 100MB file I had to up the max heap size to 2GB
-- (I'm assuming that's due to all the [Char] overhead) and it takes ~14 seconds to run.
-- The ByteString version finishes in ~2 seconds and has a max residency of ~100MB.

-- Hmmm, "bsp" has barely any speed-up going from one to two cores (~1.1X) and no speed-up going from 
-- two to four cores. Checking things out in threadscope shows all the HECs working in lock-step most of
-- the time with the last half of the run-time being one HEC making foreign calls (I'm assuming 
-- that's writing the output which can't be done until all chunks have been processed due to the reversal).
-- I thought that maybe there was contention on lazy file reading, but forcing all the dna data into memory
-- before spawning threads seems to have had no effect (I think the reverse of the chunks is probably
-- forcing all the reading already since the chunks are each strict). Oh well, I guess I can only expect so much from 
-- the addition of three tokens to an expression.

-- I don't have time to work on it now but I wonder if it woudl be better to read the file in chunks starting at the end
-- instead of having to reverse the chunks as read from the beginning. This would not require all the chunks to be
-- in memory at once.